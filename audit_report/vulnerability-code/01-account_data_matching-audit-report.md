# 🔍 攻撃ベクトル監査レポート

## ✅ 1. 攻撃ベクトル名とID

- **攻撃ベクトル:** `#1 - Account Data Matching（アカウントデータの検証不足）`

## ✅ 2. 概要（Description）

アカウントの中身（データ構造上のフィールドなど）が期待通りのものか確認せずに更新や操作を行うと、不正なアカウントを渡された場合に想定外の変更を許してしまいます。例えば「自分のVaultに対してデータ更新する」機能で、プログラムがVaultアカウントに紐づくオーナーを確認しないと、攻撃者が他人のVaultを自分のものとして引き渡し、そのデータを書き換えることが可能になります。

この監査では、プログラムがアカウント内のデータ（特に権限者フィールド）を適切に検証しているかを確認します。

## ✅ 3. 監査対象コード箇所（Code Locations）

| No. | ファイル名     | 行番号     | 関数名・Accounts構造体名 |
|-----|----------------|------------|-------------------------|
| 1   | `programs/vulnerability-code/staking-code.rs` | 19〜24行目 | `Stake` |
| 2   | `programs/vulnerability-code/staking-code.rs` | 26〜30行目 | `Unstake` |
| 3   | `programs/vulnerability-code/data-manager.rs` | 13〜19行目 | `Execute` |
| 4   | `programs/vulnerability-code/profile_manager.rs` | 19〜29行目 | `SetupProfile` |

## ✅ 4. コードレビュー結果（Code Review Result）

| チェック項目                                                | 結果（〇安全/×問題あり） |
|-------------------------------------------------------------|--------------------------|
| Accounts構造体でのデータ検証（Anchor使用時）                | × 問題あり               |
| インストラクション関数内での明示的なデータ検証              | × 問題あり               |
| 複数アカウント間のデータ整合性検証                          | × 問題あり               |

## ✅ 5. 危険なコードの抜粋（Insecure Code Snippet）

### 問題1: `staking-code.rs`の`Unstake`構造体でauthorityチェックが欠如

```rust
#[derive(Accounts)]
pub struct Unstake<'info> {
    #[account(mut)]
    pub user_stake: Account<'info, UserStake>,
    pub user: Signer<'info>,
}
```

この`Unstake`構造体では、`user_stake`アカウントの`authority`フィールドと`user`（署名者）の関連付けがありません。これにより、ユーザーは他人の`user_stake`アカウントを指定して、そのステーク量を減らすことができてしまいます。

一方、同じファイルの`Stake`構造体では適切に検証されています：

```rust
#[derive(Accounts)]
pub struct Stake<'info> {
    #[account(mut, constraint = user_stake.authority == user.key())]
    pub user_stake: Account<'info, UserStake>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

### 問題2: `data-manager.rs`の`Execute`関数でauthorityチェックが欠如

```rust
pub fn execute(ctx: Context<Execute>) -> Result<()> {
    let data = ctx.accounts.data_account.try_borrow_data()?;
    let user = User::try_from_slice(&data)?;
    msg!("Authority: {}", user.authority);
    msg!("Value: {}", user.value);
    Ok(())
}

#[derive(Accounts)]
pub struct Execute<'info> {
    pub data_account: AccountInfo<'info>,
    pub authority: Signer<'info>,
}
```

この`Execute`関数では、`data_account`から取得した`User`構造体の`authority`フィールドと、署名者である`authority`の関連付けがありません。これにより、ユーザーは他人の`data_account`を指定して、その内容を読み取ることができてしまいます。

## ✅ 6. 影響度評価（Impact Assessment）

- **重要度:** High（高）
- **潜在的影響:** 
  - `staking-code.rs`の脆弱性により、攻撃者は他のユーザーのステーク量を減らすことができます。これは資産の損失につながる可能性があります。
  - `data-manager.rs`の脆弱性により、攻撃者は他のユーザーのデータを読み取ることができます。これはプライバシーの侵害につながる可能性があります。

## ✅ 7. 推奨する修正方法（Recommended Fix）

### 問題1: `staking-code.rs`の`Unstake`構造体の修正

```rust
#[derive(Accounts)]
pub struct Unstake<'info> {
    #[account(mut, constraint = user_stake.authority == user.key())]
    pub user_stake: Account<'info, UserStake>,
    pub user: Signer<'info>,
}
```

または、Anchorの`has_one`属性を使用して：

```rust
#[derive(Accounts)]
pub struct Unstake<'info> {
    #[account(mut, has_one = authority)]
    pub user_stake: Account<'info, UserStake>,
    pub authority: Signer<'info>,
}
```

### 問題2: `data-manager.rs`の`Execute`関数の修正

```rust
pub fn execute(ctx: Context<Execute>) -> Result<()> {
    let data = ctx.accounts.data_account.try_borrow_data()?;
    let user = User::try_from_slice(&data)?;
    
    // 権限者チェックを追加
    require!(user.authority == ctx.accounts.authority.key(), ErrorCode::Unauthorized);
    
    msg!("Authority: {}", user.authority);
    msg!("Value: {}", user.value);
    Ok(())
}

#[derive(Accounts)]
pub struct Execute<'info> {
    pub data_account: AccountInfo<'info>,
    pub authority: Signer<'info>,
}
```

## ✅ 8. 監査者コメント（Auditor's Comments）

- `staking-code.rs`では、`Stake`構造体では適切に`constraint`属性を使用して権限者チェックを行っていますが、`Unstake`構造体では同様のチェックが欠如しています。これは一貫性の欠如であり、明らかな脆弱性です。
- `data-manager.rs`では、`data_account`から取得したデータの権限者と署名者の関連付けがありません。これはデータの機密性を侵害する可能性があります。
- `profile_manager.rs`では、`SetupProfile`構造体で適切にPDAを使用しており、ユーザーのPubkeyをシードに含めることで、各ユーザーが自分のプロファイルのみを操作できるようになっています。これは安全な実装です。

## ✅ 9. 再監査の推奨（Recommendation for Re-Audit）

- `staking-code.rs`と`data-manager.rs`の修正後、再監査を強く推奨します。

## ✅ 10. 監査チェックリストの記入（Audit Checklist Completion）

| チェック項目                                                | チェック結果（✓完了／×未完了） |
|-------------------------------------------------------------|--------------------------------|
| Accounts構造体のconstraint検証（Anchor使用時）              | × 未完了（`Unstake`構造体で問題あり） |
| インストラクション関数内での明示的データ整合性検証          | × 未完了（`execute`関数で問題あり） |
| 複数アカウント間の整合性チェック                            | ✓ 完了（`profile_manager.rs`は安全） |
